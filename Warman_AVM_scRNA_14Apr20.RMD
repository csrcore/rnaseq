---
title: "15Apr Warman AVM sc-RNA"
output:
  html_document:
    theme: default
    toc: TRUE
    toc_depth: 6
    toc_width: 200
    toc_float:
      collapsed: TRUE
      smooth_scroll: TRUE
      fontsize: 20pt
  pdf_document:
    toc: yes
    toc_depth: '6'
---


```{r echo=FALSE, message=FALSE, warning=FALSE}
#This code is from Chapter 9 of the Sanger scRNA Course
#https://scrnaseq-course.cog.sanger.ac.uk/website/index.html
#Additioanl Code contributed by Suyash Raj

# Make sure the folder contains the following files with identical names: barcodes.tsv, genes.tsv, matrix.mtx
# Place barcodes, matrix and gene files in a directory called files

# Check that all required packages are installed and libraries loaded
library(Seurat)
library(BiocManager)
library(tidyverse)
library(tidyr)
library(dplyr)
library(Rsamtools)
library(cowplot)
library(multtest)
library(DESeq2)
library(ggplot2)
library(gtools)
library(devtools)
library(Matrix)
library(igraph)
library(reshape)
library(DDRTree)
library(sctransform)
library(reticulate)
library(stringr)
library(monocle)
library(cellTree)
library(topGO)
library(slingshot)
library(viridis)
library(MAST)
library(RColorBrewer)
library(M3Drop)

rm(list=ls())
```


# (1) Data Curation

## Preparations
Prepare files and variables so that we can iterate through all of our code automatically
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.keep='all'}
# Set a Home Directory that will be the home to all the treatment folders
setwd("~/Desktop/rstudio/jenn_avm_scrna")
homedir <- getwd()
# Gets the name of Project
project_name <- "14Apr20_AVM"
# Date
date <- "14Apr20"

## Each treatment should match the folder name (which should contain barcodes.tsv, features.tsv, matrix.mtx)
treatments <- list("378a","378b","410","control")
```                  
                   
## Read in Data 
Read in each treatment separately and merge into one object. Normalization can be performed on individual datasets or a combined dataset; however, there are ramifications for choosing to normalize as a group (ie. merging control and treatment) or normalizing each dataset separately.
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
data_a_raw  <- Read10X(data.dir = "/Users/cmay/Desktop/rstudio/jenn_avm_scrna/378a/files/")
data_a      <- CreateSeuratObject(counts = data_a_raw, min.cells = 3, min.features  = 200, project = "378a", assay = "RNA")

data_b_raw  <- Read10X(data.dir = "/Users/cmay/Desktop/rstudio/jenn_avm_scrna/378b/files/") 
data_b      <- CreateSeuratObject(counts = data_b_raw, min.cells = 3, min.features  = 200, project = "378b", assay = "RNA")

data_c_raw  <- Read10X(data.dir = "/Users/cmay/Desktop/rstudio/jenn_avm_scrna/410/files/") 
data_c      <- CreateSeuratObject(counts = data_c_raw, min.cells = 3, min.features  = 200, project = "410", assay = "RNA")

data_d_raw  <- Read10X(data.dir = "/Users/cmay/Desktop/rstudio/jenn_avm_scrna/control/files/") 
data_d      <- CreateSeuratObject(counts = data_d_raw, min.cells = 3, min.features  = 200, project = "control", assay = "RNA")

avm_treatment <- merge(x = data_a, y = data_b, add.cell.ids = NULL, merge.data = TRUE)
avm_control   <- merge(x = data_c, y = data_d, add.cell.ids = NULL, merge.data = TRUE)

avm <- merge(x = data_a, y = c(data_b, data_c, data_d), add.cell.ids = NULL, merge.data = TRUE)
RenameCells(object = avm, add.cell.id = "avm")
```

## Check the object
Confirm that your data was properly read in and slotted into the Seurat Object
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
# Check the metadata
head(avm@meta.data)
tail(avm@meta.data)
```

# (2) Clean Data

## Quality Control
High mitochondrial RNA is indicative of damaged or dead cells, thus should be filtered
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
#Mitochondrial RNA
mito.genes1 <- grep(pattern = "^MT", x = rownames(avm@assays[["RNA"]]), value = TRUE) #^MT for human or ^mt- for mice
percent.mito1 <- Matrix::colSums(avm@assays[["RNA"]][mito.genes1])/Matrix::colSums(avm@assays[["RNA"]])
avm <- AddMetaData(object = avm, metadata = percent.mito1, col.name = "percent.mito1") 

#Ribosomal RNA
ribo.genes1 <- grep(pattern = "^^RP[SL]", x = rownames(avm@assays[["RNA"]]), value = TRUE)
percent.ribo1 <- Matrix::colSums(avm@assays[["RNA"]][ribo.genes1])/Matrix::colSums(avm@assays[["RNA"]])
avm <- AddMetaData(object = avm, metadata = percent.ribo1, col.name = "percent.ribo1") 

VlnPlot(object = avm, group.by="orig.ident", features = c("nFeature_RNA", "nCount_RNA", "percent.mito1","percent.ribo1"), ncol=2, pt.size=0)  #Change the size of the beeswarm points
```

## Cell Cycle Regression
Determine if you should regress out cell cycle genes from the model. If you see clusters correlating with specific cell cycle phases (S, G1, G2M), you may want to regres out cell cycle genes. Caution is advised if your dataset includes progenitor or stem cells, as proliferation may be colinear with cell type identity. First plot the data after performin normal regression (which can include counts, percent mitochondria and percent ribosomes). Next, regress out cell cycle genes (CC.Difference) and check the plot for changes. S, G1 and G2M should be more randomly scattered in the UMAP plot.
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
# A list of cell cycle markers, from Tirosh et al, 2015, is loaded with Seurat. 
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes

#Assign Cell Cycle Scores
avm <- CellCycleScoring(avm, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)

#View cell cycle scores and phase assignments
head(avm[[]])

avm <- FindVariableFeatures(object = avm, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5, nfeatures = 6000)

#Run PCA to see if cells segregate along cell cycle phase
avm <- ScaleData(object = avm, vars.to.regress = c("nCounts_RNA","percent.mito1"))  #can also add "percent.ribo1"
avm <- RunPCA(avm, features = c(s.genes, g2m.genes))
```

### Cell Cycle Correlation
Plot to check that no clusters are correlated with cell cycle phases
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
DimPlot(avm)
```

### Regress Cell Cycle Genes
To correct for Cell Cycle Genes, use ScaleData to regress the difference between G2M and S phase scores
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
avm$CC.Difference <- avm$S.Score - avm$G2M.Score
avm <- ScaleData(avm, vars.to.regress = "CC.Difference", features = rownames(avm))
avm <- RunPCA(avm, features = VariableFeatures(avm), nfeatures.print = 10)
```

### Replot Cell Cycle Genes
Re-plot to confirm no clusters are correlated with cell cycle phase
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
DimPlot(avm,reduction = "pca", group.by="orig.ident")
```

## Mitochondria vs Transcripts
nCount_RNA is the total number of transcripts in the cell
nFeature_RNA is the number of unique genes detected in the cell
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
plot1 <- FeatureScatter(object = avm, feature1 = "percent.mito1", feature2 = "nCount_RNA")
plot2 <- FeatureScatter(object = avm, feature1 = "percent.ribo1", feature2 = "nCount_RNA")
plot3 <- FeatureScatter(object = avm, feature1 = "G2M.Score", feature2 = "percent.ribo1")
plot4 <- FeatureScatter(object = avm, feature1 = "S.Score", feature2 = "percent.mito1")

CombinePlots(plots = list(plot1, plot2, plot3, plot4))
```

## Filter Cells 
Filter out cells based on number of genes and percent mitochondrial genes
Less than 200-500 genes indicate damaged cells. More than 5,000 genes could indicate multiplets. 
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
avm <- subset(x = avm, subset = nFeature_RNA > 200 & nFeature_RNA < 5000  & percent.mito1 < 20)
avm <- subset(x = avm, subset = nCount_RNA > 600 & nCount_RNA < 20000)
```

# (3) Visualize Data

## Plot Candidate Genes
Dimensional reduction plot, with cells colored by a quantitative feature
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
plot3 <- FeaturePlot(object = avm, features = "PECAM1")
plot4 <- FeaturePlot(object = avm, features = "MMP1")

CombinePlots(plots = list(plot3, plot4))
```

## Violin Plots
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
# Violin  plot
VlnPlot(object = avm, features = c("CDH5", "PECAM1","MMP1"), same.y.lims = TRUE, group.by="orig.ident", pt.size=0)
```

## Heatmaps
DimHeatmap shows primary sources of heterogeneity in a avm and can be useful when trying to decide which PCs to include for further downstream analyses. For instance, if cell cycle genes are high here, it may indicate that you should regress out cell cycle genes.
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
DimHeatmap(object = avm, reduction = "pca", dims=2, cells = 100, nfeature=100, balanced = TRUE)
```

# (4) Clustering the Cells
Seurat uses a graph-based clustering approach: K-nearest neighbor (KNN) graph, with edges drawn between cells with similar gene expression patterns, and then attempt to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.

## Detection of Variable Genes
FindVariableGenes calculates the average expression and dispersion for each gene, places these genes into bins, and then calculates a z-score for dispersion within each bin. This helps control for the relationship between variability and average expression. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#These parameters will vary based on the data set, heterogeneity in the sample and normalization strategy.
avm <- FindVariableFeatures(object = avm, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5, nfeatures = 5000)
head(x = HVFInfo(object = avm))

variable_genes <- (x = HVFInfo(object = avm))
write.csv(variable_genes, "/Users/cmay/Desktop/rstudio/avm_variable_genes.csv")
```

## Perform Normalization
Calculate k-nearest neighbors and construct the SNN graph
```{r echo=TRUE, message=FALSE, warning=FALSE}
## Normalize the Data
avm <- SCTransform(avm, vars.to.regress = "percent.ribo1", verbose = FALSE)
avm <- FindVariableFeatures(avm, mean.function = ExpMean, 
          dispersion.function = LogVMR, x.low.cutoff = 0.0125, 
          x.high.cutoff = 3, y.cutoff = 0.5, nfeatures = 5000) 
avm <- RunPCA(avm,npcs = 50,rev.pca = FALSE, 
          weight.by.var = TRUE,ndims.print = 1:5,
          nfeatures.print = 30,seed.use = 42,approx = TRUE) 
```

## Find Clusters
Computing Nearest Neighbor Graph
```{r echo=TRUE, message=FALSE, warning=FALSE}
avm <- FindNeighbors(avm,dims = 1:30, # Dimensions
           k.param = 15, # K neighbors
           nn.method = "annoy",
           annoy.metric = "hamming") # This is the distance metric

avm <- FindClusters(avm, resolution = 0.6, 
                    algorithm = 3, 
                    dims.use=1:30, 
                    n.start = 10,
                    n.iter = 100,
                    save.SNN=TRUE)
save(avm, file = "/Users/cmay/Desktop/rstudio/avm_clusters.csv")
```

## Run UMAP
```{r echo=TRUE, message=FALSE, warning=FALSE}
avm <- RunUMAP(avm, reduction = "pca", dims = 1:30,  # can add umap.method = "umap-learn" but don't need
           metric = "hamming", n.neighbors = 20, min.dist = 0, # This allows for tighter clustering
           n.epochs = 1000, # This repeats the algorithm 1000x to get most consistent result
           local.connectivity = 3, # minimum 3 neighbors
           verbose = TRUE)
avm_umap1 <- DimPlot(avm, group.by="Phase")
avm_umap2 <- DimPlot(avm, group.by="orig.ident")
avm_umap3 <- DimPlot(avm, group.by="SCT_snn_res.0.6")

CombinePlots(plots = list(avm_umap1, avm_umap2, avm_umap3,avm_umap3))
```


# (5) Differentially Expressed Genes
Seurat can help you find markers that define clusters via differential expression. FindAllMarkers automatically identifes positive and negative markers of a single cluster compared to all other cells. You can also test groups of clusters vs. each other, or against all cells.

## Markers for clusters
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
# Find all markers of Cluster 1
cluster0.markers <- FindMarkers(object = avm, ident.1 = 0, min.pct = 0.25)
print(x = head(x = cluster0.markers, n = 20))
write.csv(cluster0.markers, "/Users/cmay/Desktop/rstudio/cluster0.markers.csv")

# Find markers for every cluster compared to all remaining cells, report only the positive ones
#avm.all.markers <- FindAllMarkers(object = avm, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25, test.use="MAST")
avm.all.markers <- FindAllMarkers(object = avm, test.use="MAST")
avm.all.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)

write.csv(avm.all.markers, "/Users/cmay/Desktop/rstudio/avm.all.markers.csv")
```

## Heatmap 
Generates an expression heatmap for given cells and genes. 
Plot the top 10 markers for each cluster.
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
top10 <- avm.all.markers %>% group_by(cluster) %>% top_n(10, avg_logFC)
avm_heatmap <- DoHeatmap(object = avm, features = top10$gene, label = TRUE)
avm_heatmap
```

## Violin Plot
Visualizing marker expression by Treatment Group and by Clusters
VlnPlot (shows expression probability distributions across clusters)
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
avm_violinplot_genes1a <- VlnPlot(object = avm,features=c("PECAM1","MGP","CDH5","SPARC","MMP1","ALDH1A1"), same.y.lims = TRUE, group.by="orig.ident", pt.size=0)
avm_violinplot_genes1b <- VlnPlot(object = avm,features=c("PECAM1","MGP","CDH5","SPARC","MMP1","ALDH1A1"), same.y.lims = TRUE, pt.size=0)

avm_violinplot_genes1a
avm_violinplot_genes1b
```

## Violin Plot 2
Visualizing marker expression by Treatment Group and by Clusters cont.
VlnPlot (shows expression probability distributions across clusters)
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
avm_violinplot_genes2a <- VlnPlot(object = avm,features=c("TGFBI","FN1","CXCL8","GLIPR1","TFPI2","CCL2"), same.y.lims = TRUE, group.by="orig.ident", pt.size=0)
avm_violinplot_genes2b <- VlnPlot(object = avm,features=c("TGFBI","FN1","CXCL8","GLIPR1","TFPI2","CCL2"), same.y.lims = TRUE, pt.size=0)

avm_violinplot_genes2a
avm_violinplot_genes2b
```

## UMAP plot by Genes
FeaturePlot (visualizes gene expression on a tSNE or PCA plot)
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
avm_featureplot_genes <- FeaturePlot(object = avm, features = c("PECAM1","TGFBI","CDH5","ALDH1A1","SPARC","MMP1"), cols = c("grey", "blue"), reduction = "umap")
avm_featureplot_genes
```


## RidgePlot
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.keep='all'}
avm_ridgeplot_genes <- RidgePlot(object = avm,features=c("PECAM1","TGFBI","CDH5","ALDH1A1","SPARC","MMP1"))
avm_ridgeplot_genes
```


